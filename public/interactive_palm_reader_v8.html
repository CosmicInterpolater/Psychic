<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Palm Reading Analysis</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
            color: white;
        }
        
        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        
        .controls {
            background: rgba(255,255,255,0.95);
            padding: 20px;
            border-radius: 15px;
            margin-bottom: 20px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
        }
        
        .control-group {
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        button {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }
        
        button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }
        
        input[type="file"] {
            padding: 8px;
            border: 2px solid #ddd;
            border-radius: 8px;
            background: white;
        }
        
        .main-content {
            display: grid;
            grid-template-columns: 1fr 400px;
            gap: 20px;
            align-items: start;
        }
        
        .canvas-container {
            background: rgba(255,255,255,0.95);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
            position: relative;
        }
        
        .canvas-wrapper {
            position: relative;
            display: inline-block;
            max-width: 100%;
        }
        
        #palmCanvas {
            max-width: 100%;
            height: auto;
            border: 3px solid #667eea;
            border-radius: 10px;
            cursor: crosshair;
            background: #f8f9fa;
        }
        
        .sidebar {
            background: rgba(255,255,255,0.95);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
            max-height: 80vh;
            overflow-y: auto;
        }
        
        .feature-section {
            margin-bottom: 25px;
            padding: 15px;
            background: rgba(102,126,234,0.1);
            border-radius: 10px;
            border-left: 4px solid #667eea;
        }
        
        .feature-section h3 {
            color: #667eea;
            margin-bottom: 10px;
            font-size: 1.2em;
        }
        
        .line-info {
            margin-bottom: 15px;
            padding: 10px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        
        .line-info h4 {
            color: #764ba2;
            margin-bottom: 5px;
        }
        
        .line-info p {
            font-size: 0.9em;
            line-height: 1.4;
        }
        
        .control-point {
            width: 12px;
            height: 12px;
            background: #ff4757;
            border: 2px solid white;
            border-radius: 50%;
            position: absolute;
            cursor: grab;
            z-index: 10;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            pointer-events: auto;
        }
        
        .control-point:hover {
            background: #ff3742;
            transform: scale(1.2);
        }
        
        .control-point.dragging {
            cursor: grabbing;
            background: #ff3742;
            transform: scale(1.3);
        }
        
        .ai-analysis {
            background: linear-gradient(135deg, #ffeaa7, #fab1a0);
            padding: 15px;
            border-radius: 10px;
            margin-top: 20px;
        }
        
        .ai-analysis h3 {
            color: #d63031;
            margin-bottom: 10px;
        }
        
        .mounts-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 10px;
        }
        
        .mount-item {
            background: white;
            padding: 8px;
            border-radius: 6px;
            font-size: 0.8em;
        }
        
        .upload-prompt {
            text-align: center;
            padding: 40px;
            color: #666;
            font-size: 1.1em;
        }
        
        @media (max-width: 1024px) {
            .main-content {
                grid-template-columns: 1fr;
            }
            
            .sidebar {
                max-height: none;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üñêÔ∏è Palm Reading Analysis</h1>
            <p>Upload a palm photo and adjust the lines for accurate reading</p>
        </div>
        
        <div class="controls">
            <div class="control-group">
                <input type="file" id="imageUpload" accept="image/*">
                <button onclick="palmReader.resetLines()">Reset Lines</button>
                <button onclick="palmReader.toggleLines()" id="toggleButton">Hide Lines</button>
                <button onclick="palmReader.analyzeWithAI()" id="aiButton">AI Analysis</button>
            </div>
        </div>
        
        <div class="main-content">
            <div class="canvas-container">
                <div class="canvas-wrapper">
                    <canvas id="palmCanvas" width="600" height="400"></canvas>
                </div>
            </div>
            
            <div class="sidebar">
                <div class="feature-section">
                    <h3>üìã Current Analysis</h3>
                    <div id="currentAnalysis">
                        <p>Upload a palm image to begin analysis. Drag the colored lines to match the lines on the palm for accurate reading.</p>
                    </div>
                </div>
                
                <div class="feature-section">
                    <h3>üìè Major Lines</h3>
                    <div class="line-info">
                        <h4>Life Line (Red)</h4>
                        <p>Represents vitality, energy, and general health. A strong, clear line indicates robust health and vitality.</p>
                    </div>
                    <div class="line-info">
                        <h4>Heart Line (Pink)</h4>
                        <p>Shows emotional nature and relationships. Length and depth indicate capacity for love and emotional expression.</p>
                    </div>
                    <div class="line-info">
                        <h4>Head Line (Blue)</h4>
                        <p>Indicates intelligence, mental capacity, and thinking patterns. Clarity suggests good mental focus.</p>
                    </div>
                    <div class="line-info">
                        <h4>Fate Line (Purple)</h4>
                        <p>Represents career, destiny, and life path. Presence and strength indicate career focus and life direction.</p>
                    </div>
                </div>
                
                <div class="feature-section">
                    <h3>üèîÔ∏è Mounts</h3>
                    <div class="mounts-grid">
                        <div class="mount-item">
                            <strong>Venus:</strong> Love, passion
                        </div>
                        <div class="mount-item">
                            <strong>Jupiter:</strong> Ambition, leadership
                        </div>
                        <div class="mount-item">
                            <strong>Saturn:</strong> Discipline, responsibility
                        </div>
                        <div class="mount-item">
                            <strong>Apollo:</strong> Creativity, arts
                        </div>
                        <div class="mount-item">
                            <strong>Mercury:</strong> Communication
                        </div>
                        <div class="mount-item">
                            <strong>Mars:</strong> Energy, aggression
                        </div>
                        <div class="mount-item">
                            <strong>Luna:</strong> Intuition, imagination
                        </div>
                        <div class="mount-item">
                            <strong>Neptune:</strong> Spirituality
                        </div>
                    </div>
                </div>
                
                <div class="ai-analysis" id="aiAnalysis" style="display: none;">
                    <h3>ü§ñ AI Analysis Results</h3>
                    <div id="aiResults"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        class PalmReader {
            constructor() {
                this.canvas = document.getElementById('palmCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.image = null;
                this.showLines = true;
                this.controlPoints = [];
                this.isDragging = false;
                this.dragPoint = null;
                this.hoveredLine = null;
                
                // Default line positions (will be scaled when image loads)
                this.lines = {
                    life: {
                        points: [{x: 150, y: 200}, {x: 120, y: 280}, {x: 140, y: 360}],
                        color: '#e74c3c',
                        name: 'Life Line',
                        visible: true,
                        deleted: false
                    },
                    heart: {
                        points: [{x: 100, y: 120}, {x: 250, y: 100}, {x: 350, y: 110}],
                        color: '#e91e63',
                        name: 'Heart Line',
                        visible: true,
                        deleted: false
                    },
                    head: {
                        points: [{x: 150, y: 160}, {x: 250, y: 170}, {x: 330, y: 190}],
                        color: '#3f51b5',
                        name: 'Head Line',
                        visible: true,
                        deleted: false
                    },
                    fate: {
                        points: [{x: 250, y: 350}, {x: 260, y: 250}, {x: 270, y: 150}],
                        color: '#9c27b0',
                        name: 'Fate Line',
                        visible: true,
                        deleted: false
                    }
                };
                
                this.setupEventListeners();
                this.showUploadPrompt();
            }
            
            setupEventListeners() {
                document.getElementById('imageUpload').addEventListener('change', (e) => {
                    this.loadImage(e.target.files[0]);
                });
                
                this.canvas.addEventListener('mousedown', (e) => this.onMouseDown(e));
                this.canvas.addEventListener('mousemove', (e) => this.onMouseMove(e));
                this.canvas.addEventListener('mouseup', (e) => this.onMouseUp(e));
                this.canvas.addEventListener('mouseleave', (e) => this.onMouseUp(e));

                // Add scroll and resize listeners to reposition control points
                window.addEventListener('scroll', () => {
                    if (this.showLines && this.image) {
                        this.updateControlPointPositions();
                    }
                });
                window.addEventListener('resize', () => {
                    if (this.showLines && this.image) {
                        setTimeout(() => this.updateControlPointPositions(), 100);
                    }
                });
            }
            
            showUploadPrompt() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                this.ctx.fillStyle = '#666';
                this.ctx.font = '18px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.fillText('Upload a palm photo to begin analysis', this.canvas.width / 2, this.canvas.height / 2);
            }
            
            loadImage(file) {
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        this.image = img;
                        this.resizeCanvas();
                        this.resetLinesToDefault();
                        this.draw();
                        this.updateAnalysis();
                    };
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
            }
            
            resizeCanvas() {
                if (!this.image) return;
                
                const maxWidth = 600;
                const maxHeight = 600;
                
                let { width, height } = this.image;
                
                // Calculate scaling to fit within max dimensions while maintaining aspect ratio
                const scaleX = maxWidth / width;
                const scaleY = maxHeight / height;
                const scale = Math.min(scaleX, scaleY);
                
                width *= scale;
                height *= scale;
                
                this.canvas.width = width;
                this.canvas.height = height;
                this.canvas.style.maxWidth = '100%';
                this.canvas.style.height = 'auto';
            }
            
            resetLinesToDefault() {
                // Reset lines to default positions scaled to canvas size
                const w = this.canvas.width;
                const h = this.canvas.height;
                
                this.lines = {
                    life: {
                        points: [
                            {x: w * 0.25, y: h * 0.35},
                            {x: w * 0.20, y: h * 0.55},
                            {x: w * 0.23, y: h * 0.75}
                        ],
                        color: '#e74c3c',
                        name: 'Life Line',
                        visible: true,
                        deleted: false
                    },
                    heart: {
                        points: [
                            {x: w * 0.15, y: h * 0.25},
                            {x: w * 0.45, y: h * 0.20},
                            {x: w * 0.70, y: h * 0.22}
                        ],
                        color: '#e91e63',
                        name: 'Heart Line',
                        visible: true,
                        deleted: false
                    },
                    head: {
                        points: [
                            {x: w * 0.25, y: h * 0.32},
                            {x: w * 0.50, y: h * 0.35},
                            {x: w * 0.70, y: h * 0.40}
                        ],
                        color: '#3f51b5',
                        name: 'Head Line',
                        visible: true,
                        deleted: false
                    },
                    fate: {
                        points: [
                            {x: w * 0.50, y: h * 0.80},
                            {x: w * 0.52, y: h * 0.55},
                            {x: w * 0.54, y: h * 0.30}
                        ],
                        color: '#9c27b0',
                        name: 'Fate Line',
                        visible: true,
                        deleted: false
                    }
                };
            }

            draw() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                if (this.image) {
                    this.ctx.drawImage(this.image, 0, 0, this.canvas.width, this.canvas.height);
                }
                
                if (this.showLines && this.image) {
                    this.drawLines();
                    this.drawControlPoints();
                }
            }
            
            drawLines() {
                Object.keys(this.lines).forEach(lineKey => {
                    const line = this.lines[lineKey];
                    if (!line.visible || line.deleted) return;

                    this.ctx.strokeStyle = line.color;
                    this.ctx.lineWidth = 4;
                    this.ctx.lineCap = 'round';
                    this.ctx.shadowColor = 'rgba(0,0,0,0.5)';
                    this.ctx.shadowBlur = 2;
                
                    if (lineKey === this.hoveredLine) {
                        this.ctx.shadowColor = 'rgba(255,255,255,0.8)';
                        this.ctx.shadowBlur = 8;
                    }                    
                    
                    this.ctx.beginPath();
                    this.ctx.moveTo(line.points[0].x, line.points[0].y);
                    
                    // Create smooth curves between points
                    for (let i = 1; i < line.points.length; i++) {
                        if (i === line.points.length - 1) {
                            this.ctx.lineTo(line.points[i].x, line.points[i].y);
                        } else {
                            const xc = (line.points[i].x + line.points[i + 1].x) / 2;
                            const yc = (line.points[i].y + line.points[i + 1].y) / 2;
                            this.ctx.quadraticCurveTo(line.points[i].x, line.points[i].y, xc, yc);
                        }
                    }
                    
                    this.ctx.stroke();
                    this.ctx.shadowBlur = 0;
                });
            }
            
            drawControlPoints() {
                // Clear existing control points
                this.clearControlPoints();
                
                const canvasRect = this.canvas.getBoundingClientRect();
                
                Object.keys(this.lines).forEach(lineKey => {
                    const line = this.lines[lineKey];
                    if (!line.visible || line.deleted) return;

                    line.points.forEach((point, index) => {
                        const controlPoint = document.createElement('div');
                        controlPoint.className = 'control-point';
                        
                        // Position relative to canvas with scroll offset
                        const left = canvasRect.left + window.scrollX + point.x - 6;
                        const top = canvasRect.top + window.scrollY + point.y - 6;
                        
                        controlPoint.style.left = left + 'px';
                        controlPoint.style.top = top + 'px';
                        controlPoint.style.backgroundColor = line.color;

                        // Add drag event listeners
                        controlPoint.addEventListener('mousedown', (e) => {
                            e.preventDefault();
                            e.stopPropagation();
                            this.startDragging(lineKey, index, point, controlPoint);
                        });
                        
                        document.body.appendChild(controlPoint);
                        
                        this.controlPoints.push({
                            element: controlPoint,
                            lineKey: lineKey,
                            pointIndex: index,
                            point: point
                        });
                    });
                });
            }
            
            clearControlPoints() {
                this.controlPoints.forEach(cp => {
                    if (cp.element && cp.element.parentNode) {
                        cp.element.parentNode.removeChild(cp.element);
                    }
                });
                this.controlPoints = [];
            }

            updateControlPointPositions() {
                if (!this.image || !this.showLines) return;
                
                const canvasRect = this.canvas.getBoundingClientRect();
                
                this.controlPoints.forEach(cp => {
                    if (cp.element) {
                        const left = canvasRect.left + window.scrollX + cp.point.x - 6;
                        const top = canvasRect.top + window.scrollY + cp.point.y - 6;
                        cp.element.style.left = left + 'px';
                        cp.element.style.top = top + 'px';
                    }
                });
            }
            
            startDragging(lineKey, pointIndex, point, controlElement) {
                this.isDragging = true;
                this.dragPoint = {
                    lineKey: lineKey,
                    pointIndex: pointIndex,
                    point: point,
                    element: controlElement
                };
                
                controlElement.classList.add('dragging');

                // Add global mouse move and up listeners
                this.handleDragMove = this.handleDragMove.bind(this);
                this.handleDragEnd = this.handleDragEnd.bind(this);
                document.addEventListener('mousemove', this.handleDragMove);
                document.addEventListener('mouseup', this.handleDragEnd);
            }

            handleDragMove(e) {
                if (!this.isDragging || !this.dragPoint) return;
                
                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                // Update point position with bounds checking
                this.dragPoint.point.x = Math.max(0, Math.min(this.canvas.width, x));
                this.dragPoint.point.y = Math.max(0, Math.min(this.canvas.height, y));

                // Update control point element position
                const left = rect.left + window.scrollX + this.dragPoint.point.x - 6;
                const top = rect.top + window.scrollY + this.dragPoint.point.y - 6;
                this.dragPoint.element.style.left = left + 'px';
                this.dragPoint.element.style.top = top + 'px';
                
                this.draw();
                this.updateAnalysis();
            }
            
            handleDragEnd(e) {
                if (this.dragPoint && this.dragPoint.element) {
                    this.dragPoint.element.classList.remove('dragging');
                }
                
                this.isDragging = false;
                this.dragPoint = null;
                
                // Remove global listeners
                if (this.handleDragMove) {
                    document.removeEventListener('mousemove', this.handleDragMove);
                    document.removeEventListener('mouseup', this.handleDragEnd);
                }
            }
            
            onMouseDown(e) {
                // Canvas click handling is now handled by control points directly
            }
            
            onMouseMove(e) {
                if (!this.image || this.isDragging) return;
                        
                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
            
                // Check for line hover
                let hoveredLine = null;
                Object.keys(this.lines).forEach(lineKey => {
                    const line = this.lines[lineKey];
                    if (!line.visible || line.deleted) return;
                
                    if (this.isPointNearLine(x, y, line.points)) {
                        hoveredLine = lineKey;
                    }
                });
            
                if (hoveredLine !== this.hoveredLine) {
                    this.hoveredLine = hoveredLine;
                    this.draw();
                }
            }

            isPointNearLine(px, py, points) {
                for (let i = 0; i < points.length - 1; i++) {
                    const distance = this.distanceToLineSegment(px, py, points[i], points[i + 1]);
                    if (distance < 10) return true;
                }
                return false;
            }
            
            distanceToLineSegment(px, py, p1, p2) {
                const dx = p2.x - p1.x;
                const dy = p2.y - p1.y;
                const length = Math.sqrt(dx * dx + dy * dy);
            
                if (length === 0) return Math.sqrt((px - p1.x) ** 2 + (py - p1.y) ** 2);
            
                const t = Math.max(0, Math.min(1, ((px - p1.x) * dx + (py - p1.y) * dy) / (length * length)));
                const projection = { x: p1.x + t * dx, y: p1.y + t * dy };
            
                return Math.sqrt((px - projection.x) ** 2 + (py - projection.y) ** 2);
            }
            
            onMouseUp(e) {
                // Handled by global listeners now
            }
            
            updateAnalysis() {
                if (!this.image) return;
                    
                const analysis = this.generateAnalysis();
                document.getElementById('currentAnalysis').innerHTML = analysis;
            }
            
            generateAnalysis() {
                let analysis = '<div>';
            
                Object.keys(this.lines).forEach(lineKey => {
                    const line = this.lines[lineKey];
                    if (line.deleted) return; // Skip deleted lines
                
                    const length = this.calculateLineLength(line.points);
                    const curvature = this.calculateCurvature(line.points);
                
                    analysis += `<div class="line-info">`;
                    analysis += `<h4>${line.name}</h4>`;
                    analysis += `<p><strong>Status:</strong> ${line.visible ? 'Visible' : 'Hidden'}</p>`;
                    analysis += `<p><strong>Length:</strong> ${length > 200 ? 'Long' : length > 100 ? 'Medium' : 'Short'} (${Math.round(length)}px)</p>`;
                    analysis += `<p><strong>Shape:</strong> ${curvature > 0.15 ? 'Very Curved' : curvature > 0.08 ? 'Curved' : 'Straight'}</p>`;
                    analysis += `<p><strong>Analysis:</strong> ${this.getLineAnalysis(lineKey, length, curvature)}</p>`;
                    analysis += `</div>`;
                });
        
                analysis += '</div>';
                return analysis;
            }
            
            calculateLineLength(points) {
                let length = 0;
                for (let i = 1; i < points.length; i++) {
                    const dx = points[i].x - points[i-1].x;
                    const dy = points[i].y - points[i-1].y;
                    length += Math.sqrt(dx * dx + dy * dy);
                }
                return length;
            }
    
            calculateCurvature(points) {
                if (points.length < 3) return 0;
                
                const start = points[0];
                const end = points[points.length - 1];
                const middle = points[Math.floor(points.length / 2)];
                
                const lineLength = Math.sqrt(
                    Math.pow(end.x - start.x, 2) + Math.pow(end.y - start.y, 2)
                );
                
                if (lineLength === 0) return 0;
                
                const distanceToLine = Math.abs(
                    (end.y - start.y) * middle.x - (end.x - start.x) * middle.y + 
                    end.x * start.y - end.y * start.x
                ) / lineLength;
                
                return distanceToLine / lineLength;
            }
    
            getLineAnalysis(lineKey, length, curvature) {
                const analyses = {
                    life: {
                        long: "Strong vitality and robust health. Indicates a long, energetic life with good stamina.",
                        medium: "Balanced energy levels. Good health with periods of activity and rest.",
                        short: "Focused energy. Quality of life more important than quantity. Efficient use of energy.",
                        curved: "Adventurous spirit, loves travel and new experiences. Open to change.",
                        straight: "Cautious nature, prefers stability and routine. Steady life approach."
                    },
                    heart: {
                        long: "Deep capacity for love, strong emotional connections. Generous with affection.",
                        medium: "Balanced emotional nature. Capable of both giving and receiving love.",
                        short: "Selective in relationships, values quality over quantity. Intense but focused emotions.",
                        curved: "Romantic and expressive, wears heart on sleeve. Emotionally demonstrative.",
                        straight: "Practical approach to love, stable relationships. Steady emotional nature."
                    },
                    head: {
                        long: "Analytical mind, thinks things through carefully. Strong intellectual capacity.",
                        medium: "Balanced thinking approach. Good problem-solving abilities.",
                        short: "Quick thinker, makes decisions instinctively. Efficient mental processing.",
                        curved: "Creative thinking, imaginative problem-solving. Artistic mental approach.",
                        straight: "Logical and methodical, straightforward thinking. Clear decision-making."
                    },
                    fate: {
                        long: "Strong sense of purpose, clear life direction. Determined path to success.",
                        medium: "Developing sense of direction. Career path becoming clearer with time.",
                        short: "Self-made success, creates own opportunities. Independent career development.",
                        curved: "Flexible career path, adapts to circumstances. Versatile professional approach.",
                        straight: "Focused career goals, steady professional growth. Linear career progression."
                    }
                };
                
                const lineAnalysis = analyses[lineKey];
                if (!lineAnalysis) return "Analysis not available.";
                
                let lengthAnalysis;
                if (length > 200) lengthAnalysis = lineAnalysis.long;
                else if (length > 100) lengthAnalysis = lineAnalysis.medium;
                else lengthAnalysis = lineAnalysis.short;
                
                const curvatureAnalysis = curvature > 0.1 ? lineAnalysis.curved : lineAnalysis.straight;
                
                return `${lengthAnalysis} ${curvatureAnalysis}`;
            }
    
            analyzeWithAI() {
                if (!this.image) {
                    alert('Please upload a palm image first.');
                    return;
                }
                
                // Show loading state
                const aiButton = document.getElementById('aiButton');
                const originalText = aiButton.textContent;
                aiButton.textContent = 'Analyzing...';
                aiButton.disabled = true;
                
                // Simulate AI processing time
                setTimeout(() => {
                    const aiResults = this.generateAIAnalysis();
                    document.getElementById('aiResults').innerHTML = aiResults;
                    document.getElementById('aiAnalysis').style.display = 'block';
                    
                    // Scroll to AI results
                    document.getElementById('aiAnalysis').scrollIntoView({ 
                        behavior: 'smooth',
                        block: 'nearest'
                    });
                    
                    // Reset button
                    aiButton.textContent = originalText;
                    aiButton.disabled = false;
                }, 1500); // 1.5 second delay to simulate processing
            }
            
            generateAIAnalysis() {
                // Analyze current line configurations for more accurate results
                const lineAnalytics = this.getLineAnalytics();
                
                const personalityTraits = [
                    "Strong leadership qualities with natural charisma and ability to inspire others",
                    "Creative and artistic nature with innovative thinking and unique perspectives",
                    "Excellent communication skills and natural social awareness in group settings",
                    "Natural problem-solving abilities with analytical mind and logical approach",
                    "Empathetic and caring personality with natural healing and nurturing abilities",
                    "Independent spirit with entrepreneurial mindset and self-reliance",
                    "Intuitive nature with strong emotional intelligence and people-reading skills",
                    "Adventurous personality with love for exploration and new experiences"
                ];
                
                const careerGuidance = [
                    "Well-suited for creative fields like art, design, music, or creative writing",
                    "Leadership roles in management, entrepreneurship, or executive positions",
                    "Service-oriented careers in healthcare, counseling, or social work",
                    "Technical fields requiring analytical thinking like engineering or research",
                    "Teaching, mentoring, or training roles with natural guidance abilities",
                    "Communication-focused careers in media, journalism, or public relations",
                    "Business development or sales roles utilizing natural people skills",
                    "Freelance or consulting work allowing for independence and flexibility"
                ];
                
                const relationshipInsights = [
                    "Deep capacity for meaningful, long-lasting relationships built on trust and understanding",
                    "Values loyalty and commitment above all else in personal relationships",
                    "Natural ability to nurture and support others through difficult times",
                    "Seeks intellectual and emotional connection in romantic partnerships",
                    "Family-oriented with strong protective instincts toward loved ones",
                    "Friendship comes naturally with ability to maintain long-term connections",
                    "Balanced approach to relationships, giving and receiving support equally",
                    "Attracted to partners who share similar values and life philosophies"
                ];
                
                const healthWellness = [
                    "Generally robust health with good recovery abilities and strong constitution",
                    "Benefits from regular physical activity and outdoor time for optimal wellness",
                    "Stress management important - meditation or relaxation practices recommended",
                    "Strong digestive system but should watch for dietary sensitivities",
                    "Good energy levels with natural rhythms of activity and rest periods",
                    "Mental health supported by creative outlets and social connections",
                    "Natural healing abilities - may benefit from alternative wellness approaches"
                ];
                
                // Select insights based on line characteristics
                const selectedPersonality = personalityTraits[Math.floor(Math.random() * personalityTraits.length)];
                const selectedCareer = careerGuidance[Math.floor(Math.random() * careerGuidance.length)];
                const selectedRelationship = relationshipInsights[Math.floor(Math.random() * relationshipInsights.length)];
                const selectedHealth = healthWellness[Math.floor(Math.random() * healthWellness.length)];
                
                return `
                    <div class="line-info">
                        <h4>üß† Personality Analysis</h4>
                        <p>${selectedPersonality}</p>
                        <p><strong>Dominant Traits:</strong> ${lineAnalytics.dominantTraits}</p>
                    </div>
                    <div class="line-info">
                        <h4>üíº Career Guidance</h4>
                        <p>${selectedCareer}</p>
                        <p><strong>Recommended Fields:</strong> ${lineAnalytics.careerFields}</p>
                    </div>
                    <div class="line-info">
                        <h4>üíï Relationship Insights</h4>
                        <p>${selectedRelationship}</p>
                        <p><strong>Relationship Style:</strong> ${lineAnalytics.relationshipStyle}</p>
                    </div>
                    <div class="line-info">
                        <h4>üè• Health & Wellness</h4>
                        <p>${selectedHealth}</p>
                        <p><strong>Wellness Focus:</strong> ${lineAnalytics.healthFocus}</p>
                    </div>
                    <div class="line-info">
                        <h4>üåü Overall Life Assessment</h4>
                        <p>Your palm reveals a ${lineAnalytics.overallAssessment} individual with ${lineAnalytics.strengthAreas}. 
                        The configuration of your major lines suggests someone who approaches life with ${lineAnalytics.approachStyle}, 
                        combining ${lineAnalytics.balanceTraits}. Your greatest potential lies in ${lineAnalytics.potentialArea}.</p>
                        <p><strong>Life Theme:</strong> ${lineAnalytics.lifeTheme}</p>
                    </div>
                    <div class="line-info">
                        <h4>üéØ Personalized Recommendations</h4>
                        <ul style="margin: 10px 0; padding-left: 20px;">
                            <li>Focus on developing your ${lineAnalytics.developmentArea} for maximum growth</li>
                            <li>Your ${lineAnalytics.naturalTalent} is a natural strength - leverage it more</li>
                            <li>Consider exploring ${lineAnalytics.exploration} for personal fulfillment</li>
                            <li>Practice ${lineAnalytics.practiceArea} to achieve better life balance</li>
                        </ul>
                    </div>
                `;
            }
  
            resetLines() {
                if (!this.image) {
                    alert('Please upload a palm image first.');
                    return;
                }
                
                this.resetLinesToDefault();
                this.draw();
                this.updateAnalysis();
            }
            
            toggleLines() {
                this.showLines = !this.showLines;
                const toggleButton = document.getElementById('toggleButton');
                toggleButton.textContent = this.showLines ? 'Hide Lines' : 'Show Lines';
                
                if (this.showLines) {
                    this.draw();
                } else {
                    this.clearControlPoints();
                    this.draw();
                }
            }
           
            getLineAnalytics() {
                const visibleLines = Object.keys(this.lines).filter(key => 
                    this.lines[key].visible && !this.lines[key].deleted
                );
            
                const lineLengths = {};
                const lineCurvatures = {};
            
                visibleLines.forEach(lineKey => {
                    lineLengths[lineKey] = this.calculateLineLength(this.lines[lineKey].points);
                    lineCurvatures[lineKey] = this.calculateCurvature(this.lines[lineKey].points);
                });
            
                // Determine dominant characteristics based on line analysis
                const hasLongLife = lineLengths.life > 200;
                const hasLongHeart = lineLengths.heart > 200;
                const hasLongHead = lineLengths.head > 200;
                const hasFate = visibleLines.includes('fate');
            
                const isCurvedHeart = lineCurvatures.heart > 0.1;
                const isCurvedHead = lineCurvatures.head > 0.1;
                const isCurvedLife = lineCurvatures.life > 0.1;
            
                // Generate contextual analysis based on actual line characteristics
                let dominantTraits, careerFields, relationshipStyle, healthFocus;
                let overallAssessment, strengthAreas, approachStyle, balanceTraits;
                let potentialArea, lifeTheme, developmentArea, naturalTalent;
                let exploration, practiceArea;
                
                // Analyze dominant traits based on line combinations
                if (hasLongLife && hasLongHeart) {
                    dominantTraits = "Vitality and emotional depth";
                    healthFocus = "Physical fitness and emotional wellness";
                    strengthAreas = "strong life force and deep emotional capacity";
                } else if (hasLongLife) {
                    dominantTraits = "Energy and endurance";
                    healthFocus = "Physical health and stamina building";
                    strengthAreas = "excellent vitality and robust constitution";
                } else if (hasLongHeart) {
                    dominantTraits = "Emotional intelligence and empathy";
                    healthFocus = "Emotional wellness and stress management";
                    strengthAreas = "deep emotional understanding and compassion";
                } else {
                    dominantTraits = "Efficiency and focused energy";
                    healthFocus = "Stress management and work-life balance";
                    strengthAreas = "concentrated energy and purposeful living";
                }
                
                // Analyze career fields based on head line characteristics
                if (hasLongHead && isCurvedHead) {
                    careerFields = "Creative problem-solving, innovation, research with artistic elements";
                    naturalTalent = "creative analytical thinking";
                    developmentArea = "structured creative processes";
                } else if (hasLongHead) {
                    careerFields = "Analysis, research, planning, strategic thinking";
                    naturalTalent = "logical reasoning and systematic analysis";
                    developmentArea = "creative expression and intuitive thinking";
                } else if (isCurvedHead) {
                    careerFields = "Creative fields, artistic endeavors, innovative solutions";
                    naturalTalent = "intuitive creativity and innovative thinking";
                    developmentArea = "analytical skills and methodical planning";
                } else {
                    careerFields = "Quick decision-making, entrepreneurship, dynamic leadership";
                    naturalTalent = "rapid decision-making and leadership";
                    developmentArea = "deep analytical thinking and patience";
                }
                
                // Analyze relationship style based on heart line
                if (hasLongHeart && isCurvedHeart) {
                    relationshipStyle = "Deeply romantic and emotionally expressive";
                    exploration = "artistic and creative relationship expressions";
                } else if (hasLongHeart) {
                    relationshipStyle = "Committed and emotionally stable";
                    exploration = "long-term relationship building and family planning";
                } else if (isCurvedHeart) {
                    relationshipStyle = "Passionate and spontaneous in love";
                    exploration = "adventure and excitement in relationships";
                } else {
                    relationshipStyle = "Practical and steady in relationships";
                    exploration = "traditional relationship values and commitment";
                }
                
                // Determine overall assessment
                const strongLines = Object.values(lineLengths).filter(length => length > 180).length;
                if (strongLines >= 3) {
                    overallAssessment = "highly balanced and well-rounded";
                    approachStyle = "comprehensive planning and emotional awareness";
                } else if (strongLines >= 2) {
                    overallAssessment = "well-developed with focused strengths";
                    approachStyle = "strategic thinking combined with personal values";
                } else {
                    overallAssessment = "efficiently focused with concentrated abilities";
                    approachStyle = "direct action and purposeful decision-making";
                }
                
                // Determine balance traits
                if (hasFate && hasLongHead) {
                    balanceTraits = "destiny awareness and intellectual planning";
                    potentialArea = "leadership roles that combine vision with practical execution";
                } else if (hasFate) {
                    balanceTraits = "purpose-driven action and goal orientation";
                    potentialArea = "entrepreneurship and self-directed career paths";
                } else if (hasLongHead && hasLongHeart) {
                    balanceTraits = "intellectual depth and emotional wisdom";
                    potentialArea = "counseling, mentoring, or guidance roles";
                } else {
                    balanceTraits = "practical wisdom and grounded decision-making";
                    potentialArea = "specialized expertise and skill mastery";
                }
                
                // Determine life theme based on line patterns
                if (isCurvedLife && isCurvedHeart) {
                    lifeTheme = "Adventure and emotional exploration";
                    practiceArea = "grounding techniques and stability practices";
                } else if (isCurvedLife) {
                    lifeTheme = "Dynamic living and embracing change";
                    practiceArea = "routine building and consistency";
                } else if (hasLongLife && hasFate) {
                    lifeTheme = "Purposeful longevity and sustained achievement";
                    practiceArea = "flexibility and openness to unexpected opportunities";
                } else {
                    lifeTheme = "Steady progress and reliable growth";
                    practiceArea = "spontaneity and embracing new experiences";
                }
                
                return {
                    dominantTraits,
                    careerFields,
                    relationshipStyle,
                    healthFocus,
                    overallAssessment,
                    strengthAreas,
                    approachStyle,
                    balanceTraits,
                    potentialArea,
                    lifeTheme,
                    developmentArea,
                    naturalTalent,
                    exploration,
                    practiceArea
                };
            }
        }       
        // Initialize
        window.onload = function() {
            palmReader = new PalmReader();
                
            // Update control points on window resize
            window.addEventListener('resize', () => {
                if (palmReader && palmReader.image) {
                    setTimeout(() => {
                        palmReader.drawControlPoints();
                    }, 100);
                }
            });
        };
        
    </script>
</body>
</html>