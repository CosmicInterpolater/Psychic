# Sample Test Plan: Assuming Phase 1 is Complete

This is a sample test plan assuming Phase 1 (Backend Implementation - Core Authentication & User Management) is complete. This demonstrates how I would approach test generation for completed tasks.

## Test Suite for: Firebase Authentication Service

**A. Relevant Completed Task IDs:**
- Task 3.1: Set Up Firebase Admin SDK
- Task 3.2: Implement Authentication Service

**B. Test Strategy:**
- **Unit Tests:**
  - Target File(s): `server/services/auth.service.js`
  - Focus: Test token verification, custom token creation, session management, password reset
  - Mocks: Mock Firebase Admin SDK responses

- **Integration Tests:**
  - Target: Authentication service with Firebase Admin SDK
  - Focus: Verify proper integration with Firebase services
  - Mocks: Minimal mocking, use Firebase local emulator when possible

**C. Generated Test Code:**

### Unit Tests

**File:** `server/tests/unit/services/auth.service.test.js`

```javascript
const { verifyToken, createCustomToken, resetPassword } = require('../../../services/auth.service');
const admin = require('firebase-admin');

// Mock Firebase Admin SDK
jest.mock('firebase-admin', () => ({
  auth: jest.fn().mockReturnValue({
    verifyIdToken: jest.fn(),
    createCustomToken: jest.fn(),
    generatePasswordResetLink: jest.fn()
  })
}));

describe('Authentication Service', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  describe('verifyToken', () => {
    it('should verify a valid token', async () => {
      const mockDecodedToken = { uid: 'user123', email: 'user@example.com' };
      admin.auth().verifyIdToken.mockResolvedValue(mockDecodedToken);
      
      const result = await verifyToken('valid-token');
      
      expect(admin.auth().verifyIdToken).toHaveBeenCalledWith('valid-token');
      expect(result).toEqual(mockDecodedToken);
    });

    it('should throw an error for invalid token', async () => {
      admin.auth().verifyIdToken.mockRejectedValue(new Error('Invalid token'));
      
      await expect(verifyToken('invalid-token')).rejects.toThrow('Invalid token');
    });
  });

  describe('createCustomToken', () => {
    it('should create a custom token for a user', async () => {
      admin.auth().createCustomToken.mockResolvedValue('custom-token-123');
      
      const result = await createCustomToken('user123');
      
      expect(admin.auth().createCustomToken).toHaveBeenCalledWith('user123');
      expect(result).toBe('custom-token-123');
    });
  });

  describe('resetPassword', () => {
    it('should generate a password reset link', async () => {
      const mockResetLink = 'https://example.com/reset?token=abc123';
      admin.auth().generatePasswordResetLink.mockResolvedValue(mockResetLink);
      
      const result = await resetPassword('user@example.com');
      
      expect(admin.auth().generatePasswordResetLink).toHaveBeenCalledWith('user@example.com');
      expect(result).toBe(mockResetLink);
    });
  });
});
```

### Integration Tests

**File:** `server/tests/integration/auth.integration.test.js`

```javascript
const request = require('supertest');
const app = require('../../server');
const admin = require('firebase-admin');

// Use Firebase emulator for testing
process.env.FIREBASE_AUTH_EMULATOR_HOST = 'localhost:9099';

describe('Authentication API Integration', () => {
  let testUserUid;
  
  beforeAll(async () => {
    // Create a test user in Firebase Auth emulator
    const userRecord = await admin.auth().createUser({
      email: 'test@example.com',
      password: 'password123'
    });
    testUserUid = userRecord.uid;
  });
  
  afterAll(async () => {
    // Clean up test user
    await admin.auth().deleteUser(testUserUid);
  });
  
  describe('POST /api/auth/verify-token', () => {
    it('should verify a valid token', async () => {
      // Get a valid token from Firebase Auth
      const customToken = await admin.auth().createCustomToken(testUserUid);
      
      const response = await request(app)
        .post('/api/auth/verify-token')
        .send({ token: customToken });
      
      expect(response.status).toBe(200);
      expect(response.body).toHaveProperty('uid', testUserUid);
    });
    
    it('should return 401 for invalid token', async () => {
      const response = await request(app)
        .post('/api/auth/verify-token')
        .send({ token: 'invalid-token' });
      
      expect(response.status).toBe(401);
    });
  });
});
```

## Test Suite for: User Data Model & Repository

**A. Relevant Completed Task IDs:**
- Task 4.1: Define User Data Model
- Task 4.2: Implement User Repository

**B. Test Strategy:**
- **Unit Tests:**
  - Target File(s): `server/models/user.model.js`, `server/services/user.service.js`
  - Focus: Test model validation, CRUD operations
  - Mocks: Mock Firestore responses

- **Integration Tests:**
  - Target: User service with Firestore
  - Focus: Verify proper data storage and retrieval
  - Mocks: Use Firestore emulator

**C. Generated Test Code:**

### Unit Tests

**File:** `server/tests/unit/models/user.model.test.js`

```javascript
const UserModel = require('../../../models/user.model');

describe('User Model', () => {
  it('should create a valid user model', () => {
    const userData = {
      uid: 'user123',
      email: 'user@example.com',
      displayName: 'Test User',
      role: 'user',
      createdAt: new Date(),
      updatedAt: new Date()
    };
    
    const user = new UserModel(userData);
    
    expect(user).toMatchObject(userData);
  });
  
  it('should validate required fields', () => {
    const createInvalidUser = () => {
      return new UserModel({
        email: 'user@example.com' // missing uid and other required fields
      });
    };
    
    expect(createInvalidUser).toThrow();
  });
});
```

**File:** `server/tests/unit/services/user.service.test.js`

```javascript
const { createUser, getUserByUid, updateUser, deleteUser } = require('../../../services/user.service');
const admin = require('firebase-admin');

// Mock Firestore
jest.mock('firebase-admin', () => {
  const mockDoc = {
    set: jest.fn().mockResolvedValue({}),
    get: jest.fn(),
    update: jest.fn().mockResolvedValue({}),
    delete: jest.fn().mockResolvedValue({})
  };
  
  const mockWhere = jest.fn().mockReturnThis();
  const mockCollection = {
    doc: jest.fn().mockReturnValue(mockDoc),
    where: mockWhere
  };
  
  return {
    firestore: jest.fn().mockReturnValue({
      collection: jest.fn().mockReturnValue(mockCollection)
    })
  };
});

describe('User Service', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });
  
  describe('createUser', () => {
    it('should create a user in Firestore', async () => {
      const userData = {
        uid: 'user123',
        email: 'user@example.com',
        displayName: 'Test User'
      };
      
      await createUser(userData);
      
      expect(admin.firestore().collection).toHaveBeenCalledWith('users');
      expect(admin.firestore().collection().doc).toHaveBeenCalledWith('user123');
      expect(admin.firestore().collection().doc().set).toHaveBeenCalledWith(
        expect.objectContaining({
          uid: 'user123',
          email: 'user@example.com',
          displayName: 'Test User',
          createdAt: expect.any(Date),
          updatedAt: expect.any(Date),
          role: 'user'
        })
      );
    });
  });
  
  describe('getUserByUid', () => {
    it('should retrieve a user from Firestore', async () => {
      const mockUserData = {
        uid: 'user123',
        email: 'user@example.com',
        displayName: 'Test User'
      };
      
      admin.firestore().collection().doc().get.mockResolvedValue({
        exists: true,
        data: () => mockUserData
      });
      
      const result = await getUserByUid('user123');
      
      expect(admin.firestore().collection).toHaveBeenCalledWith('users');
      expect(admin.firestore().collection().doc).toHaveBeenCalledWith('user123');
      expect(result).toEqual(mockUserData);
    });
    
    it('should return null for non-existent user', async () => {
      admin.firestore().collection().doc().get.mockResolvedValue({
        exists: false
      });
      
      const result = await getUserByUid('nonexistent');
      
      expect(result).toBeNull();
    });
  });
});
```

## Behavioral Test Scenarios

1. **User Registration Flow**
   - User navigates to registration page
   - Enters valid credentials and submits form
   - System creates user in Firebase Auth
   - System creates user profile in Firestore
   - User receives confirmation and is redirected to dashboard

2. **User Authentication Flow**
   - User navigates to login page
   - Enters valid credentials and submits form
   - System authenticates with Firebase
   - User session is created
   - Protected routes become accessible

3. **Profile Management Flow**
   - Authenticated user navigates to profile page
   - Updates profile information
   - System validates and saves changes to Firestore
   - User sees success confirmation

4. **Reading History Management Flow**
   - User completes a psychic reading
   - System saves reading to user's history
   - User navigates to history page
   - System retrieves and displays all past readings
   - User can view details of specific readings
